import { useEffect, useRef, useState } from "react";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { $getRoot, $createTextNode, $createParagraphNode } from "lexical";
import { $createStyledElementNode } from "./nodes/StyledElementNode";

const CHUNK_SIZE = 5;

function HtmlFileUploader() {
  const [editor] = useLexicalComposerContext();
  const [allChunks, setAllChunks] = useState([]);
  const [loadedChunkIndex, setLoadedChunkIndex] = useState(0);
  const sentinelRef = useRef(null);

  const handleFileChange = (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const htmlString = e.target.result;
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      const body = doc.body;

      const elements = Array.from(body.childNodes);
      const chunked = [];
      for (let i = 0; i < elements.length; i += CHUNK_SIZE) {
        chunked.push(elements.slice(i, i + CHUNK_SIZE));
      }

      setAllChunks(chunked);
      setLoadedChunkIndex(1); // Load first chunk
    };

    reader.readAsText(file);
  };

  useEffect(() => {
    if (loadedChunkIndex === 0 || loadedChunkIndex > allChunks.length) return;

    const chunk = allChunks[loadedChunkIndex - 1];
    editor.update(() => {
      const root = $getRoot();
      chunk.forEach((child) => {
        insertNodeFromDOM(child, root);
      });

      // Add sentinel node at the end
      const sentinelParagraph = $createParagraphNode();
      sentinelParagraph.setFormat("left");
      sentinelParagraph.append($createTextNode("")); // empty node
      root.append(sentinelParagraph);
    });
  }, [loadedChunkIndex]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting && loadedChunkIndex < allChunks.length) {
          console.log("ðŸ” Sentinel visible, loading next chunk");
          setLoadedChunkIndex((prev) => prev + 1);
        }
      },
      {
        root: document.querySelector(".editor-scroll-container"),
        threshold: 0.1,
      }
    );

    const el = document.querySelector(".editor-scroll-container div[contenteditable] p:last-child");
    if (el) {
      sentinelRef.current = el;
      observer.observe(el);
    }

    return () => observer.disconnect();
  }, [loadedChunkIndex, allChunks.length]);

  const insertNodeFromDOM = (child, parentLexicalNode) => {
    let lexicalNode = null;

    if (child.nodeType === Node.TEXT_NODE) {
      const text = child.textContent.trim();
      if (text) {
        parentLexicalNode.append($createTextNode(text));
      }
      return;
    }

    if (child.nodeType !== Node.ELEMENT_NODE) return;

    const tag = child.tagName.toLowerCase();
    const style = child.getAttribute("style") || "";

    switch (tag) {
      case "p":
      case "div":
      case "span":
      case "section":
      case "article":
      case "header":
      case "footer":
      case "main":
      case "aside":
      case "thead":
      case "tbody":
      case "tfoot":
      case "tr":
      case "td":
      case "th":
      case "h1":
      case "h2":
      case "h3":
      case "ul":
      case "ol":
      case "li":
      case "mark":
      case "br":
      case "sup":
      case "sub":
      case "hr":
        lexicalNode = $createStyledElementNode(style, tag);
        break;

      case "a": {
        const href = child.getAttribute("href") || "";
        lexicalNode = $createStyledElementNode(style, tag, href);
        break;
      }

      case "table":
        lexicalNode = $createStyledElementNode(style, "table");
        break;

      default:
        console.warn("ðŸš« Unsupported tag ignored:", tag);
        lexicalNode = $createStyledElementNode(style, tag); // fallback
        break;
    }

    if (lexicalNode) {
      parentLexicalNode.append(lexicalNode);
      Array.from(child.childNodes).forEach((nested) =>
        insertNodeFromDOM(nested, lexicalNode)
      );
    }
  };

  return (
    <div className="p-2">
      <input type="file" accept=".html" onChange={handleFileChange} />
    </div>
  );
}

export default HtmlFileUploader;
