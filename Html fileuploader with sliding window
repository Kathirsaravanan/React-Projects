import { useEffect, useState, useRef } from "react"; import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext"; import { $createTextNode, $getRoot, $createParagraphNode } from "lexical"; import { $createStyledElementNode } from "./nodes/StyledElementNode"; import { clearChunks } from "../../../DB/indexDB";

const CHUNK_SIZE = 30;

function HtmlFileUploader({ scrollContainerRef }) { const [editor] = useLexicalComposerContext(); const [allChunks, setAllChunks] = useState([]); const [centerChunkIndex, setCenterChunkIndex] = useState(2); const [loadedChunkRange, setLoadedChunkRange] = useState({ start: 0, end: 4 });

const lastScrollTopRef = useRef(0);

const handleFileChange = (event) => { const file = event.target.files?.[0]; if (!file) return;

const reader = new FileReader();
reader.onload = async (e) => {
  const htmlString = e.target.result;
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlString, "text/html");
  const body = doc.body;
  const elements = Array.from(body.childNodes);

  const chunked = [];
  for (let i = 0; i < elements.length; i += CHUNK_SIZE) {
    chunked.push(elements.slice(i, i + CHUNK_SIZE));
  }

  await clearChunks();
  setAllChunks(chunked);
  setCenterChunkIndex(2);
  setLoadedChunkRange({ start: 0, end: 4 });
};

reader.readAsText(file);

};

const insertNodeFromDOM = (child, parentLexicalNode) => { if (child.nodeType === Node.TEXT_NODE) { const text = child.textContent.trim(); if (text) { const paragraph = $createParagraphNode(); paragraph.append($createTextNode(text)); parentLexicalNode.append(paragraph); } return; }

if (child.nodeType !== Node.ELEMENT_NODE) return;

const tag = child.tagName.toLowerCase();
const style = child.getAttribute("style") || "";
const lexicalNode = $createStyledElementNode(style, tag);

if (lexicalNode) {
  parentLexicalNode.append(lexicalNode);
  Array.from(child.childNodes).forEach((nested) =>
    insertNodeFromDOM(nested, lexicalNode)
  );
}

};

const getRequiredChunkRange = (centerIndex) => { const start = Math.max(0, centerIndex - 2); const end = Math.min(allChunks.length - 1, centerIndex + 2); return { start, end }; };

const loadChunksWindow = async (centerIndex) => { const newRange = getRequiredChunkRange(centerIndex); const indicesToLoad = []; for (let i = newRange.start; i <= newRange.end; i++) { indicesToLoad.push(i); }

editor.update(() => {
  const root = $getRoot();
  root.clear();

  indicesToLoad.forEach((index) => {
    const chunk = allChunks[index];
    if (!chunk) return;

    const wrapper = $createParagraphNode();
    wrapper.setFormat("left");
    wrapper.setIndent(0);
    wrapper.setDirection("ltr");
    wrapper.setTextAlignment("left");

    wrapper.append($createTextNode(`--- Chunk ${index + 1} ---`));
    root.append(wrapper);

    chunk.forEach((child) => {
      try {
        insertNodeFromDOM(child, root);
      } catch (err) {
        console.error(`Error inserting node from chunk ${index}:`, err);
      }
    });
  });
});

setLoadedChunkRange(newRange);

};

const handleScroll = () => { const container = scrollContainerRef.current; if (!container || allChunks.length === 0) return;

const scrollTop = container.scrollTop;
const scrollDirection = scrollTop > lastScrollTopRef.current ? "down" : "up";
lastScrollTopRef.current = scrollTop;

const chunkElements = container.querySelectorAll("[data-chunk-index]");
chunkElements.forEach((el) => {
  const rect = el.getBoundingClientRect();
  const index = parseInt(el.getAttribute("data-chunk-index"));

  if (scrollDirection === "down" && rect.top < container.clientHeight && index > centerChunkIndex) {
    setCenterChunkIndex(index);
  }

  if (scrollDirection === "up" && rect.top > 0 && rect.top < 200 && index < centerChunkIndex) {
    setCenterChunkIndex(index);
  }
});

};

useEffect(() => { if (allChunks.length > 0) { loadChunksWindow(centerChunkIndex); } }, [centerChunkIndex, allChunks]);

useEffect(() => { const container = scrollContainerRef.current; if (!container) return;

const onScroll = () => handleScroll();
container.addEventListener("scroll", onScroll, { passive: true });
return () => container.removeEventListener("scroll", onScroll);

}, [centerChunkIndex, allChunks]);

return ( <div className="p-2"> <input type="file" accept=".html" onChange={handleFileChange} /> </div> ); }

export default HtmlFileUploader;

