import { useEffect, useState } from "react";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { $createTextNode, $getRoot } from "lexical";
import { $createStyledElementNode } from "./nodes/StyledElementNode";

const CHUNK_SIZE = 50;

function HtmlFileUploader({ scrollContainerRef }) {
  const [editor] = useLexicalComposerContext();
  const [allChunks, setAllChunks] = useState([]);
  const [currentChunkIndex, setCurrentChunkIndex] = useState(0);

  const handleFileChange = (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const htmlString = e.target.result;
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      const body = doc.body;
      const elements = Array.from(body.childNodes);

      const chunked = [];
      for (let i = 0; i < elements.length; i += CHUNK_SIZE) {
        chunked.push(elements.slice(i, i + CHUNK_SIZE));
      }

      setAllChunks(chunked);
      setCurrentChunkIndex(0);
    };

    reader.readAsText(file);
  };

  const debounce = (func, delay) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), delay);
    };
  };

  const insertNodeFromDOM = (child, parentLexicalNode) => {
    if (child.nodeType === Node.TEXT_NODE) {
      const text = child.textContent.trim();
      if (text) {
        parentLexicalNode.append($createTextNode(text));
      }
      return;
    }

    if (child.nodeType !== Node.ELEMENT_NODE) return;

    const tag = child.tagName.toLowerCase();
    const style = child.getAttribute("style") || "";

    const lexicalNode = $createStyledElementNode(style, tag);
    if (lexicalNode) {
      parentLexicalNode.append(lexicalNode);
      Array.from(child.childNodes).forEach((nested) =>
        insertNodeFromDOM(nested, lexicalNode)
      );
    }
  };

  const switchChunk = (newIndex) => {
    // Save current editor state to localStorage
    editor.update(() => {
      const editorState = editor.getEditorState();
      const json = JSON.stringify(editorState.toJSON());
      localStorage.setItem(`html_chunk_${currentChunkIndex}`, json);
    });

    setCurrentChunkIndex(newIndex);
  };

  const loadChunk = (index) => {
    if (!allChunks.length || index < 0 || index >= allChunks.length) return;

    const saved = localStorage.getItem(`html_chunk_${index}`);
    if (saved) {
      const parsedState = editor.parseEditorState(JSON.parse(saved));
      editor.setEditorState(parsedState);
    } else {
      const chunk = allChunks[index];
      editor.update(() => {
        const root = $getRoot();
        root.clear();
        chunk.forEach((child) => insertNodeFromDOM(child, root));
      });
    }

    if (scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = 0;
    }
  };

  useEffect(() => {
    loadChunk(currentChunkIndex);
  }, [currentChunkIndex, allChunks]);

  const handleScroll = () => {
    const container = scrollContainerRef.current;
    if (!container) return;

    const { scrollTop, scrollHeight, clientHeight } = container;
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);

    if (distanceFromBottom <= 10 && currentChunkIndex < allChunks.length - 1) {
      switchChunk(currentChunkIndex + 1);
    } else if (scrollTop <= 10 && currentChunkIndex > 0) {
      switchChunk(currentChunkIndex - 1);
    }
  };

  useEffect(() => {
    const container = scrollContainerRef.current;
    if (container) {
      const debouncedScroll = debounce(handleScroll, 100);
      container.addEventListener("scroll", debouncedScroll);

      return () => {
        container.removeEventListener("scroll", debouncedScroll);
      };
    }
  }, [scrollContainerRef, currentChunkIndex, allChunks]);

  return (
    <div className="p-2">
      <input type="file" accept=".html" onChange={handleFileChange} />
      {allChunks.length > 0 && (
        <p className="text-sm text-green-600 mt-2">
          ðŸ“¦ Showing chunk {currentChunkIndex + 1} of {allChunks.length}
        </p>
      )}
    </div>
  );
}

export default HtmlFileUploader;
