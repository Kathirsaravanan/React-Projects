import { useEffect, useState } from "react";
import { useLexicalComposerContext } from "@lexical/react/LexicalComposerContext";
import { $createTextNode, $getRoot } from "lexical";
import { $createStyledElementNode } from "./nodes/StyledElementNode";
import {
  saveChunkToDB,
  getChunkFromDB,
  deleteOtherChunks
} from "./db";

const CHUNK_SIZE = 50;

function HtmlFileUploader({ scrollContainerRef }) {
  const [editor] = useLexicalComposerContext();
  const [allChunks, setAllChunks] = useState([]);
  const [currentChunkIndex, setCurrentChunkIndex] = useState(0);
  const [cachedChunks, setCachedChunks] = useState({});

  const handleFileChange = (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const htmlString = e.target.result;
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlString, "text/html");
      const body = doc.body;
      const elements = Array.from(body.childNodes);

      const chunked = [];
      for (let i = 0; i < elements.length; i += CHUNK_SIZE) {
        chunked.push(elements.slice(i, i + CHUNK_SIZE));
      }

      setAllChunks(chunked);
      setCurrentChunkIndex(0);
      setCachedChunks({});
    };

    reader.readAsText(file);
  };

  const debounce = (func, delay) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), delay);
    };
  };

  const insertNodeFromDOM = (child, parentLexicalNode) => {
    if (child.nodeType === Node.TEXT_NODE) {
      const text = child.textContent.trim();
      if (text) {
        parentLexicalNode.append($createTextNode(text));
      }
      return;
    }

    if (child.nodeType !== Node.ELEMENT_NODE) return;

    const tag = child.tagName.toLowerCase();
    const style = child.getAttribute("style") || "";

    const lexicalNode = $createStyledElementNode(style, tag);
    if (lexicalNode) {
      parentLexicalNode.append(lexicalNode);
      Array.from(child.childNodes).forEach((nested) =>
        insertNodeFromDOM(nested, lexicalNode)
      );
    }
  };

  const saveChunk = async (index) => {
    editor.update(() => {
      const editorState = editor.getEditorState();
      const json = editorState.toJSON();
      saveChunkToDB(index, json);
      setCachedChunks((prev) => ({
        ...prev,
        [index]: json,
      }));
    });
  };

  const restoreChunk = async (index) => {
    const saved = cachedChunks[index] || await getChunkFromDB(index);
    if (saved) {
      const parsedState = editor.parseEditorState(saved);
      editor.setEditorState(parsedState);
    } else {
      const chunk = allChunks[index];
      editor.update(() => {
        const root = $getRoot();
        root.clear();
        chunk.forEach((child) => insertNodeFromDOM(child, root));
      });
    }
  };

  const maintainCacheWindow = async (centerIndex) => {
    const keep = [centerIndex - 1, centerIndex, centerIndex + 1].filter(
      (i) => i >= 0 && i < allChunks.length
    );

    await deleteOtherChunks(keep);
  };

  const switchChunk = async (newIndex) => {
    if (newIndex < 0 || newIndex >= allChunks.length) return;

    await saveChunk(currentChunkIndex);
    setCurrentChunkIndex(newIndex);
  };

  const loadChunk = async (index) => {
    if (!allChunks.length || index < 0 || index >= allChunks.length) return;

    await restoreChunk(index);

    if (scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = 0;
    }

    [index - 1, index + 1].forEach(async (i) => {
      if (i >= 0 && i < allChunks.length && !cachedChunks[i]) {
        const saved = await getChunkFromDB(i);
        if (saved) {
          setCachedChunks((prev) => ({
            ...prev,
            [i]: saved,
          }));
        }
      }
    });

    await maintainCacheWindow(index);
  };

  useEffect(() => {
    loadChunk(currentChunkIndex);
  }, [currentChunkIndex, allChunks]);

  const handleScroll = () => {
    const container = scrollContainerRef.current;
    if (!container) return;

    const { scrollTop, scrollHeight, clientHeight } = container;
    const distanceFromBottom = scrollHeight - (scrollTop + clientHeight);

    if (distanceFromBottom <= 10 && currentChunkIndex < allChunks.length - 1) {
      switchChunk(currentChunkIndex + 1);
    } else if (scrollTop <= 10 && currentChunkIndex > 0) {
      switchChunk(currentChunkIndex - 1);
    }
  };

  useEffect(() => {
    const container = scrollContainerRef.current;
    if (container) {
      const debouncedScroll = debounce(handleScroll, 100);
      container.addEventListener("scroll", debouncedScroll);
      return () => container.removeEventListener("scroll", debouncedScroll);
    }
  }, [scrollContainerRef, currentChunkIndex, allChunks]);

  return (
    <div className="p-2">
      <input type="file" accept=".html" onChange={handleFileChange} />
      {allChunks.length > 0 && (
        <p className="text-sm text-green-600 mt-2">
          ðŸ“¦ Showing chunk {currentChunkIndex + 1} of {allChunks.length}
        </p>
      )}
    </div>
  );
}

export default HtmlFileUploader;
